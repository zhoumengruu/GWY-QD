### 预览pdf

```vue
<!--
 * @Author: 周梦茹
 * @Date: 2020-12-29 17:59:52
 * @LastEditors: 周梦茹
 * @LastEditTime: 2021-10-19 10:30:23
 * @Description: 预览pdf
 * @FilePath: \bussiness\src\lib\PreviewPdfAll\index.vue
-->
// url 在浏览器直接打开时直接下载
<template>
  <section class="preview-pdf" ref="preview-pdf" v-loading.fullscreen.lock="isSpin">
    <section class="content" ref="pdf-content">
      <pdf
        v-for="i in numPages"
        :src="src"
        :page="i"
        @progress="loadedRatio = $event"
        @page-loaded="pageLoaded($event)"
        @num-pages="pageTotalNum = $event"
        @error="pdfError($event)"
        @link-clicked="page = $event"
        :key="i"
      ></pdf>

    </section>
  </section>
</template>

<script>
import Vue from 'vue';
import { Loading } from 'element-ui';
import pdf from 'vue-pdf';

Vue.use(Loading);

export default {
  name: 'PreviewPdf',
  components: {
    pdf
  },
  props: {
    url: {
      type: String,
      required: true
    }
  },
  data () {
    return {
      isSpin: true,
      pageNum: 1,
      pageTotalNum: 1,
      pageRotate: 0,
      // 加载进度
      loadedRatio: 0,
      curPageNum: 0,
      src: '',
      numPages: 1
    };
  },
  mounted () {
    setTimeout(() => {
      this.pageNum = 1;
      const loadingTask = pdf.createLoadingTask(`${this.url}`); // pdf.createLoadingTask(`${this.url}`);

      this.src = loadingTask;
      this.src.promise.then((res) => {
        this.numPages = res.numPages;
      });
    }, 0);
  },
  methods: {
    // 页面加载回调函数，其中e为当前页数
    pageLoaded (e) {
      if (e === this.numPages) {
        this.isSpin = false;
      }
    },
    // 其他的一些回调函数。
    pdfError (error) {
      console.error(error);
    }
  }
};
</script>

<style lang="scss">
.preview-pdf {
  width: 100%;
  height: 100%;
  padding: 0 3rem;
  overflow: hidden;

  .controls {
    line-height: 0.45rem;

    .btn {
      display: inline-block;
      width: 0.6rem;
      height: 0.3rem;
      line-height: 0.3rem;
      text-align: center;
      border-radius: 0.05rem;
      color: #fff;
      background: #1559bd;
      cursor: pointer;

      &.prev {
        margin-right: 0.15rem;
      }
    }
  }

  .content {
    height: 100%;
    overflow: auto;

    > span {
      width: 100%;
    }
  }
}
</style>

```

### 预览excel

```vue
<!--
 * @Author: 周梦茹
 * @Date: 2020-12-29 17:59:52
 * @LastEditors: 周梦茹
 * @LastEditTime: 2021-10-22 11:50:56
 * @Description: 预览excel
 * @FilePath: \bussiness\src\lib\PreviewExcel\index.vue
-->
// url在浏览器打开直接可下载
<template>
  <a-spin size="large" :spinning="isSpin">
    <section class="preview-excel" ref="preview-excel">
      <div v-for="(item, index) in tableList" :key="index" v-html="drawTable(item)" class="excel-div"></div>
    </section>
  </a-spin>
</template>

<script>
import Vue from 'vue';
import { Spin } from 'ant-design-vue';
import axios from 'axios';
import XLSX from 'xlsx';

Vue.use(Spin);

export default {
  name: 'PreviewExcel',
  props: {
    url: {
      type: String,
      required: true
    },
    ip: {
      type: String,
      default: '/FileServer/'
    }
  },
  data () {
    return {
      isSpin: true,
      tableList: []
    };
  },
  watch: {
    url: {
      handler (val) {
        if (this.$refs['preview-excel']) {
          this.$refs['preview-excel'].innerHTML = '';
        }
        this.getExcel(val);
      },
      immediate: true
    }
  },
  methods: {
    getExcel (url) {
      this.isSpin = true;
      axios.get(`${this.ip}${url}`, { responseType: 'arraybuffer' }).then((res) => {
        this.data = new Blob([res.data], {
          type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        });
        const fileReader = new FileReader();

        fileReader.onload = (e) => {
          const { result } = e.target;
          // 以二进制流方式读取得到整份excel表格对象
          const workbook = XLSX.read(result, { type: 'binary' });

          const { SheetNames } = workbook;

          SheetNames.forEach((item) => this.tableList.push(workbook.Sheets[item]));
        };
        fileReader.readAsBinaryString(this.data);
        this.isSpin = false;
      });
    },

    drawTable (item) {
      if (item['!ref']) {
        return XLSX.utils.sheet_to_html(item);
      }
    }
  }
};
</script>

<style lang="scss">
.preview-excel {
  width: 100%;
  max-height: 7.5rem;
  padding-bottom: 0.3rem;
  overflow: auto;
  .excel-div {
    margin: 1rem;
  }

  .ant-spin-spinning {
    position: absolute;
    top: 45%;
  }

  table {
    width: 100%;
    tr {
      td {
        line-height: 0.3rem;
        border: 1px solid #ccc;
      }
    }
    tr:first-child {
      background-color: #dfe4ef;
      color: #606266;
      td {
        min-width: 1rem;
      }
    }
  }
}
</style>

```

### 解析xml

```vue
/*
 * @Author: wanglei
 * @Date: 2020-11-23 10:15:05
 * @LastEditTime: 2021-09-29 16:16:17
 * @LastEditors: 王佳宾
 * @Description: 将算法渲染方案xml解析成数组对象方便调用
 * @FilePath: \src\utils\utils\parseXMLByMaxV.js
 */
/**
 * @param {xml} data
 * @return {Array}
 */
export default function parseXMLByMaxV (data) {
  const result = [];
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(data, 'text/xml');
  const pluginArray = xmlDoc.getElementsByTagName('Plugin');
  const len = pluginArray.length;

  let unit = ''; // 单位

  for (let i = 0; i < len; i += 1) {
    const ele1 = pluginArray[i];

    let obj = {};
    const prodName = ele1.getAttribute('ProdName');
    const useLabel = ele1.getAttribute('label');
    const reMapArr = ele1.getElementsByTagName('ReMaps')[0].children;

    unit = ele1.getElementsByTagName('ReMaps')[0].getAttribute('Unit');
    const reMaps = [];

    for (let j = 0; j < reMapArr.length; j += 1) {
      const ele2 = reMapArr[j];
      const color = ele2
        .getAttribute('Color')
        .split(',')
        .map((item) => Number(item));
      // 如果长度是三，说明没有设置透明色，默认设置为1

      if (color.length === 3) {
        color.push(1);
      }

      // 第一行插入第一个分级的最小值
      if (j === 0) {
        reMaps.push({
          color,
          value: ele2.getAttribute('MinV'),
          label: ''
        });
      }

      const maxV = ele2.getAttribute('MaxV');
      const label = ele2.getAttribute('Label');

      reMaps.push({
        color,
        value: maxV,
        label
      });
    }

    obj = {
      prodName,
      reMaps,
      useLabel,
      unit
    };
    result.push(obj);
  }
  return result;
}

```

### 导出excel

```js
export default function exportExcel ( exportUrl, excelName, requestParams) {
  axios({
    method: 'POST',
    url: exportUrl,
    data: requestParams,
    responseType: 'blob'
  }).then((res) => {
    if (res.status === 200) {
      const blob = new Blob([res.data], {
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8'
      });
      const url = window.URL.createObjectURL(blob);
      const aLink = document.createElement('a');

      aLink.style.display = 'none';
      aLink.href = url;
      aLink.setAttribute('download', excelName);
      document.body.appendChild(aLink);
      aLink.click();
      document.body.removeChild(aLink);
      window.URL.revokeObjectURL(url);
    }
  });
}
```

### 计算数组中每个元素出现的次数

```js
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];

let nameNum = names.reduce((pre,cur)=>{
  if(cur in pre){
    pre[cur]++
  }else{
    pre[cur] = 1 
  }
  return pre
},{})
console.log(nameNum);
// reduce接受一个函数和初始值： arr.reduce((pre.cur,curindex,arr)=>{}，[])
// 初始值可以是各种数据类型，包括对象数组
// 函数里面接受四个参数，(初始元素，当前元素，当前元素索引，当前元素所属对象)
// 前两个参数是必须的
```

### 比较两个对象

```js
function deepCompare(a, b) {
    // 类型相同，值或引用相同，那肯定相同
    if (a === b) { return true; }

    // 如果 a 或者 b 中有一个是 null 或 undefined，那二者不同，
    // 因此在这个条件下，a 和 b 可能相同的情况已经在前一条分支中过滤掉了。
    // 同时这个分支结合上一条分支，排除掉了 null 和 undefiend 的情况，之后不用判空了。
    if (a === null || b === null || a === undefined || b === undefined) {
        return false;
    }

    const [aType, bType] = [a, b].map(it => typeof (it));
    // 如果 a 和 b 类型不同，那就不同
    if (aType !== bType) { return false; }

    // 我们重点要深入判断的是对象和数组，它们的 typeof 运算结果都是 "object"，
    // 其他类型就简单判断。前面已经处理了等值和空值的情况，剩下的就直接返回 false 了
    if (aType !== "object") { return false; }

    if (Array.isArray(a)) {
        // 作为数组进行比较，数组是一个单独的逻辑，
        // 使用 IIFE 封装是为了保证能 return，避免混入后面的逻辑。
        // 所以这里的 IIFE 不是必须的。
        return (() => {
            if (a.length !== b.length) { return false; }
            for (const i in a) {
                if (!deepCompare(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        })();
    }

    // 使用之前的逻辑判断对象，记得把属性值判断那里改成递归判断，
    // 使用 IIFE 封装逻辑
    return (() => {
        // 先判断属性个数，如果属性个数不等，那肯定不相同
        const aEntries = Object.entries(a);
        const bEntries = Object.entries(b);
        if (aEntries.length !== bEntries.length) {
            return false;
        }

        // 再遍历逐一判断属性，只要有一个不等，那就整个不相同
        for (const [key, value] of aEntries) {
            if (!deepCompare(value, b[key])) { return false; }
        }

        return true;
    })();
}
```

